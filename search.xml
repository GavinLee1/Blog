<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[常见分布式全局唯一ID生成策略及算法的对比]]></title>
      <url>%2F2017%2F06%2F28%2F%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94%2F</url>
      <content type="text"><![CDATA[全局唯一的 ID 几乎是所有系统都会遇到的刚需。这个 id 在搜索, 存储数据, 加快检索速度 等等很多方面都有着重要的意义。工业上有多种策略来获取这个全局唯一的id，针对常见的几种场景，我在这里进行简单的总结和对比。 简单分析一下需求 [1]所谓全局唯一的 id 其实往往对应是生成唯一记录标识的业务需求。 这个 id 常常是数据库的主键，数据库上会建立聚集索引（cluster index），即在物理存储上以这个字段排序。这个记录标识上的查询，往往又有分页或者排序的业务需求。所以往往要有一个time字段，并且在time字段上建立普通索引（non-cluster index）。普通索引存储的是实际记录的指针，其访问效率会比聚集索引慢，如果记录标识在生成时能够基本按照时间有序，则可以省去这个time字段的索引查询。 这就引出了记录标识生成（也就是上文提到的三个XXX-id）的两大核心需求： 全局唯一 趋势有序 常见生成策略的优缺点对比 [2]方法一: 用数据库的 auto_increment 来生成优点： 此方法使用数据库原有的功能，所以相对简单 能够保证唯一性 能够保证递增性 id 之间的步长是固定且可自定义的 缺点： 可用性难以保证：数据库常见架构是 一主多从 + 读写分离，生成自增ID是写请求 主库挂了就玩不转了 扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且 难以扩展 改进方案： 冗余主库，避免写入单点 数据水平切分，保证各主库生成的ID不重复 如上图所述，由1个写库变成3个写库，每个写库设置不同的 auto_increment 初始值，以及相同的增长步长，以保证每个数据库生成的ID是不同的（上图中库0生成0,3,6,9…，库1生成1,4,7,10，库2生成2,5,8,11…） 改进后的架构保证了可用性，但缺点是 丧失了ID生成的“绝对递增性”：先访问库0生成0,3，再访问库1生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，目标是趋势递增，不是绝对递增 数据库的写压力依然很大，每次生成ID都要访问数据库 为了解决这些问题，引出了以下方法： 方法二：单点批量ID生成服务 分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。 数据库写压力大，是因为每次生成ID都访问了数据库，可以使用批量的方式降低数据库写压力。 如上图所述，数据库使用双master保证可用性，数据库中只存储当前ID的最大值，例如4。 ID生成服务假设每次批量拉取5个ID，服务访问数据库，将当前ID的最大值修改为4，这样应用访问ID生成服务索要ID，ID生成服务不需要每次访问数据库，就能依次派发0,1,2,3,4这些ID了。 当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是数据库的压力就降低到原来的1/6。 优点： 保证了ID生成的绝对递增有序 大大的降低了数据库的压力，ID生成可以做到每秒生成几万几十万个 缺点： 服务仍然是单点 如果服务挂了，服务重启起来之后，继续生成ID可能会不连续，中间出现空洞（服务内存是保存着0,1,2,3,4，数据库中max-id是4，分配到3时，服务重启了，下次会从5开始分配，3和4就成了空洞，不过这个问题也不大） 虽然每秒可以生成几万几十万个ID，但毕竟还是有性能上限，无法进行水平扩展 改进方案 单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点： 如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。这个切换的过程对调用方是透明的，可以自动完成，常用的技术是 vip+keepalived，具体就不在这里展开。另外，ID-gen-service也可以实施水平扩展，以解决上述缺点，但会引发一致性问题。 方法三：uuid / guid 不管是通过数据库，还是通过服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。uuid是一种常见的本地生成ID的方法。1UUID uuid = UUID.randomUUID(); 优点： 本地生成ID，不需要进行远程调用，时延低 扩展性好，基本可以认为没有性能上限 缺点： 无法保证趋势递增 uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性） 方法四：取当前毫秒数 uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？ - 取当前毫秒数是一种常见方案。 优点： 本地生成ID，不需要进行远程调用，时延低 生成的ID趋势递增 生成的ID是整数，建立索引后查询效率高 缺点： 如果并发量超过1000，会生成重复的ID 这个缺点要了命了，不能保证ID的唯一性。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。 方法五：使用 Redis 来生成 id当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR 和 INCRBY 来实现。 优点： 依赖于数据库，灵活方便，且性能优于数据库。 数字ID天然排序，对分页或者需要排序的结果很有帮助。 缺点： 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。 需要编码和配置的工作量比较大。 方法六：Twitter 开源的 Snowflake 算法snowflake 是 twitter 开源的分布式ID生成算法，其核心思想为，一个long型的ID： 41 bit 作为毫秒数 - 41位的长度可以使用69年 10 bit 作为机器编号 （5个bit是数据中心，5个bit的机器ID） - 10位的长度最多支持部署1024个节点 12 bit 作为毫秒内序列号 - 12位的计数顺序号支持每个节点每毫秒产生4096个ID序号 算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。 该算法 java 版本的实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136 public class SnowflakeIdGenerator &#123; //================================================Algorithm's Parameter============================================= // 系统开始时间截 (UTC 2017-06-28 00:00:00) private final long startTime = 1498608000000L; // 机器id所占的位数 private final long workerIdBits = 5L; // 数据标识id所占的位数 private final long dataCenterIdBits = 5L; // 支持的最大机器id(十进制)，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) // -1L 左移 5位 (worker id 所占位数) 即 5位二进制所能获得的最大十进制数 - 31 private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 支持的最大数据标识id - 31 private final long maxDataCenterId = -1L ^ (-1L &lt;&lt; dataCenterIdBits); // 序列在id中占的位数 private final long sequenceBits = 12L; // 机器ID 左移位数 - 12 (即末 sequence 所占用的位数) private final long workerIdMoveBits = sequenceBits; // 数据标识id 左移位数 - 17(12+5) private final long dataCenterIdMoveBits = sequenceBits + workerIdBits; // 时间截向 左移位数 - 22(5+5+12) private final long timestampMoveBits = sequenceBits + workerIdBits + dataCenterIdBits; // 生成序列的掩码(12位所对应的最大整数值)，这里为4095 (0b111111111111=0xfff=4095) private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); //=================================================Works's Parameter================================================ /** * 工作机器ID(0~31) */ private long workerId; /** * 数据中心ID(0~31) */ private long dataCenterId; /** * 毫秒内序列(0~4095) */ private long sequence = 0L; /** * 上次生成ID的时间截 */ private long lastTimestamp = -1L; //===============================================Constructors======================================================= /** * 构造函数 * * @param workerId 工作ID (0~31) * @param dataCenterId 数据中心ID (0~31) */ public SnowflakeIdGenerator(long workerId, long dataCenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format("Worker Id can't be greater than %d or less than 0", maxWorkerId)); &#125; if (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format("DataCenter Id can't be greater than %d or less than 0", maxDataCenterId)); &#125; this.workerId = workerId; this.dataCenterId = dataCenterId; &#125; // ==================================================Methods======================================================== // 线程安全的获得下一个 ID 的方法 public synchronized long nextId() &#123; long timestamp = currentTime(); //如果当前时间小于上一次ID生成的时间戳: 说明系统时钟回退过 - 这个时候应当抛出异常 if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException( String.format("Clock moved backwards. Refusing to generate id for %d milliseconds", lastTimestamp - timestamp)); &#125; //如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) &#123; sequence = (sequence + 1) &amp; sequenceMask; //毫秒内序列溢出 即 序列 &gt; 4095 if (sequence == 0) &#123; //阻塞到下一个毫秒,获得新的时间戳 timestamp = blockTillNextMillis(lastTimestamp); &#125; &#125; //时间戳改变，毫秒内序列重置 else &#123; sequence = 0L; &#125; //上次生成ID的时间截 lastTimestamp = timestamp; //移位并通过或运算拼到一起组成64位的ID return ((timestamp - startTime) &lt;&lt; timestampMoveBits) // | (dataCenterId &lt;&lt; dataCenterIdMoveBits) // | (workerId &lt;&lt; workerIdMoveBits) // | sequence; &#125; // 阻塞到下一个毫秒 即 直到获得新的时间戳 protected long blockTillNextMillis(long lastTimestamp) &#123; long timestamp = currentTime(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = currentTime(); &#125; return timestamp; &#125; // 获得以毫秒为单位的当前时间 protected long currentTime() &#123; return System.currentTimeMillis(); &#125; //====================================================Test Case===================================================== public static void main(String[] args) &#123; SnowflakeIdGenerator idWorker = new SnowflakeIdGenerator(0, 0); for (int i = 0; i &lt; 1000; i++) &#123; long id = idWorker.nextId(); System.out.println(Long.toBinaryString(id)); System.out.println(id); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅入浅出 SpringBoot 集成 Mybatis]]></title>
      <url>%2F2017%2F03%2F17%2F%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA-SpringBoot-%E9%9B%86%E6%88%90-Mybatis%2F</url>
      <content type="text"><![CDATA[最近看李笑来的一本众创书《新生》。迷上里面一个词”重生”(不是穿越剧里面的那个玩意儿), 以及”再生”, “反复重生”。说的是换新行业的重生，学新知识的重生，换新环境的重生，等等诸如此类。大概意思其实就是”Stay hungry, stay foolish”。里面提了几个接地气儿的观点：”复利”, “践行” 和 “主动选择”。所以，自从新公司入职开始，有很多新东西可以学，总体感觉 very excited。SpringBoot + Mybatis 就是其中的基础。算算时间，试用期结束的日子快到了。所以写点东西，也算是对这段时间学习的一个小小的交代。纯属个人编程经验总结，如果有什么不严谨的地方，欢迎评论指正 。 照例解释几个概念 [1]SpringBoot: Spring 是个在教科书里都已经存在 N 多年的东西了。随着 Convension Over Configureation 这个概念被越来越多的开发者接受并使用。Spring 略显臃肿的配置文件让这个 J2EE 元老级的框架，越发显得捉襟见肘。所以, 顺应MicroServices的潮流，SpringBoot 应运而生。用来构建基于Spring框架的标准化的独立部署应用程序。（“再也tmd不用寄人篱下，活在WebContainer的屋檐下了”）。 Spring Boot简化了基于Spring的应用开发，你只需要”run”就能创建一个独立的，产品级别的Spring应用。 我们为Spring平台及第三方库提供开箱即用的设置，这样你就可以有条不紊地开始。多数Spring Boot应用只需要很少的Spring配置。 Mybatis: 说白了就是操作数据库的。 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 Mybatis - Spring: Mybatis针对Spring的适配版本, 可以用依赖注入的方式调用SqlSession。 MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。 使用这个类库中的类, Spring 将会加载必要的 MyBatis 工厂类和 session 类。 这个类库也提供一个简单的方式来注入 MyBatis 数据映射器和 SqlSession 到业务层的 bean 中。 而且它也会处理事务, 翻译 MyBatis 的异常到 Spring 的 DataAccessException 异常(数据访问异常,译者注)中。最终,它并不会依赖于 MyBatis,Spring 或 MyBatis-Spring 来构建应用程序代码。 话不多说 先看看Demo [2]源码地址 -&gt; https://github.com/GavinLee1/HelloMybatis.git 项目运行起来之后 浏览器输入 [localhost:8080/swagger-ui.html] 进行访问 本项目，主要实现了以下几个 API : CreateUser GetUserById ListUserByIdList 访问 API 返回的 Response Message 长这个样子: 从开发环境开始讲起 [3]技术环境 [3.1] Framwork: SpringBoot, Mybatis IDE: Intellij Project Manager: Maven Version Control: Git Prgrammong Language: Java 用Intellij 新建一个空项目 [3.2]1.直接新建一个空的 maven peoject 就行了 2.填写maven项目的参数 3.给项目取个名字 4.以上几步都成功了的话，初始项目的结构大概是这个样子的 需要添加的 Maven Dependencies [3.3]SpringBoot 相关的 Dependencies注意添加parent节点123456789101112131415161718192021222324252627282930313233343536&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.8.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;spring-boot.version&gt;1.3.8.RELEASE&lt;/spring-boot.version&gt; &lt;spring.context.version&gt;4.2.4.RELEASE&lt;/spring.context.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.context.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Mybatis 相关的 Dependencies123456789101112131415161718&lt;properties&gt; &lt;mybatis.version&gt;3.4.2&lt;/mybatis.version&gt; &lt;mybatis-spring.version&gt;1.3.1&lt;/mybatis-spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 数据库连接需要的 Dependencies123456789101112131415161718&lt;properties&gt; &lt;spring-jdbc.version&gt;4.3.5.RELEASE&lt;/spring-jdbc.version&gt; &lt;mysql-connector.version&gt;5.1.38&lt;/mysql-connector.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-jdbc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 项目结构 [3.4]根据 MVC 模式的大原则，本项目的结构如下图所示。 Controller 接受上层 view 传回的参数，进行处理之后，返回 view 所需要的数据 Service 层主要处理核心业务逻辑，比如最常见的 合法性判断，业务运算，逻辑聚合，封装返回值等等 Dao 层作为数据的中转站，对各类数据源进行整合。只是整合数据源 不处理业务逻辑 然后就是具体的数据层 这个布局和设计是我个人比较习惯的方式。但是，系统设计从来都是一件仁则见仁，智者见智的事情。所以，最好是能找到一种适合自己风格的方式。 具体来看 大概是如下的层次结构： 数据库表 [3.5]建表语句如下123456789CREATE TABLE `user` ( `id` int(10) NOT NULL AUTO_INCREMENT, `name` varchar(60) DEFAULT NULL, `gender` tinyint(4) DEFAULT NULL, `birthday` datetime DEFAULT NULL, `email` varchar(60) DEFAULT NULL, `phone` varchar(20) DEFAULT NULL, PRIMARY KEY (`id`))DEFAULT CHARSET=utf8; 整体上有了个映像之后 我们一步一步拆开看吧 首先 最重要的是 - SpringBoot [4]先让 SpringBoot飞 [4.1]1.我一般习惯性在根目录下新建一个叫做Application.java的文件作为启动器 2.然后, 像所以 Java 程序一样，你需要一个 main 函数 3.在 Application 的头上戴个帽子(注解) @SpringBootApplication 这个注解其实等价于 @Configuration + @EnableAutoConfiguration + @ComponentScan。用哪个得根据需求和喜好了，当然还有版本。 4.看起来应该是这个样子:123456789@ComponentScan(basePackages = &#123;"com.hello.mybatis"&#125;) @Configuration@EnableAutoConfiguration(exclude=&#123; DataSourceAutoConfiguration.class&#125;)public class Application &#123; public static void main(String [] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 5.然后，amazing的事情发生了: 你的 SpringBoot 项目已经可以启动运行了 - “妈妈再也不用担心 So easy 系列” 我常用的 SpringBoot 注解 [4.2]SpringBoot 官方文档洋洋洒洒几百页。其实，你只要会 Java，再了解一下这些注解的作用。使用起来也就没啥障碍了。平时需要什么的时候，再查就好了。然后，我平时常用的注解有这么几个:@Configuration@Bean@Value@Service@Controller@Repository@Inject@Named… 引入外部配置文件 和 配置数据源的 两种方式 [4.3]其实， 针对外部配置文件， Spring 框架已经帮我们考虑了很多。不过有时候根据项目需要，我们也得手动导入一些配置文件信息。所以，这里特别就这两种方式，进行简单说明。 1.自定义的配置文件根目录(比如示例项目的 /conf 目录)这个目录位置可以在 pom.xml 文件中进行配置，比如：1234567&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;conf&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 2.SpringBoot 自动导入配置文件 自动注入数据源在此根目录下新建一个 application.properties 文件。这个文件里的参数值会被 SpringBoot 自动载入。然后可以在项目中通过注解 @Value 进行访问 例如：12@Value("$&#123;host:127.0.0.1&#125;")private String HOST; 这里 : 后为未找到该参数项时的默认值。如果不添加默认值，那么，读取不到该参数时，会抛 IllegalArgumentException。载入时，参数类型不匹配也会抛异常。 至于自动载入数据源的问题，大体类似。首先在 pom.xml 里面添加关于 jdbc 和 MySQL connector 的 dependency。然后，在 application.properties 文件中根据 SpringBoot 的命名规范添加相关信息就可以了。完成之后，在项目中，就可以用 @Inject DataSource dataSource 的方式访问这个数据源了。通过这种方式，也可以配置多个数据源。 application.properties中数据源配置信息的命名格式1234spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=root 3.手动载入配置文件 并 配置数据源新建配置文件(比如 jdbc.properties)。然后在项目中，进行手动载入和调用。具体如下: jdbc.properties1234567dataSourceClassName=com.mysql.jdbc.jdbc2.optional.MysqlDataSourcedataSource.url=jdbc:mysql://localhost:3306/testdataSource.user=rootdataSource.password=rootdataSource.cachePrepStmts=truedataSource.prepStmtCacheSize=250dataSource.prepStmtCacheSqlLimit=2048 配置DataSource这里推荐一个高性能的 DataSource - HikariDataSource 为了使用这个DataSource，需要添加Dependency: 12345&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;/dependency&gt; 数据源配置：1234567891011121314151617@Bean(name = "userDataSource")public DataSource userDataSource() &#123; HikariDataSource mysqlDS = null; try &#123; Resource resource = new ClassPathResource("jdbc.properties"); Properties props = PropertiesLoaderUtils.loadProperties(resource); HikariConfig config = new HikariConfig(props) &#123; &#125;; mysqlDS = new HikariDataSource(config); log.info("[Mybatis] - Database connection pool created!"); &#125; catch (IOException e) &#123; log.error("[Mybatis] - Error connecting data source", e); &#125; return mysqlDS;&#125; Mybatis 必知必会 [5]通过Mapper访问数据库 [5.1]这里有两层意思:a) 具体的sql都写在mapper中b)上层需要获得mapper去访问数据库 sql写在哪儿？ [5.2]a) 可以写在定义mapper的interface 中b) 可以写在 *Mapper.xml中这里使用第二种方法，个人感觉写在 xml 文件中，能更加方便的使用mybatis的 动态sql 特性 SqlSession [5.3]我们需要SqlSession去打开一个会话。之后,你可以使用它来执行映射语句,提交或回滚连接,最后,当不再需要它的时候, 你可以关闭session。 使用 MyBatis-Spring 之后, 你的 bean 可以通过一个线程安全的 SqlSession 来注入,基于 Spring 的事务配置 来自动提交,回滚,关闭 session。 不再需要手动关闭SqlSession。 SqlSessionTemplate [5.4]为了获得SqlSession。我们需要SqlSessionTemplate。SqlSessionTemplate 是 MyBatis-Spring 的核心。 这个类负责管理 MyBatis 的 SqlSession, 调用 MyBatis 的 SQL 方法, 翻译异常。 SqlSessionTemplate 是线程安全的, 可以被多个 DAO 所共享使用。当调用 SQL 方法时, 包含从映射器 getMapper()方法返回的方法, SqlSessionTemplate 将会保证使用的 SqlSession 是和当前 Spring 的事务相关的。此外,它管理 session 的生命 周期,包含必要的关闭,提交或回滚操作。12345@Bean(name = "userSqlSessionTemplate")public SqlSessionTemplate ringsAccountSqlSessionTemplate(@Named("userSqlSessionFactory") SqlSessionFactory sqlSessionFactory) &#123; log.info("[Mybatis] - Loaded the SqlSessionTemplate with name userSqlSessionTemplate!"); return new SqlSessionTemplate(sqlSessionFactory);&#125; SqlSessionFactory [5.5]为了获得SqlSessionTemplate。我们需要SqlSessionFactory。为了获得SqlSessionFactory。我们需要一个DataSource。DataSource的注入方法，在前面已经阐述过了，此处就不在赘述。1234567891011121314151617@Bean(name = "userSqlSessionFactory")public SqlSessionFactory userSqlSessionFactory() throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(userDataSource()); sqlSessionFactoryBean.setTypeAliasesPackage("com.hello.mybatis.repository.domain"); ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); sqlSessionFactoryBean.setMapperLocations(resolver.getResources("classpath:mybatis/*Mapper.xml")); log.info("[Mybatis] - Loaded the userSqlSessionFactory!"); return (SqlSessionFactory) sqlSessionFactoryBean.getObject();&#125; 请注意他们的依赖次序 mapper -&gt; SqlSession -&gt; SqlSessionTemplate -&gt; SqlSessionFactory -&gt; DataSource 准备工作完毕之后 [haha] [6]定义 POJO 模型 [6.1]毕竟示例程序，越简单越好。这里就整个最普通的 User 模型。考虑到篇幅，getter， setter 和 constructer 我没贴出来。感兴趣的可以直接去看源码。User 里的 id 作为唯一标识这个对象的 自增 主键。12345678public class User &#123; private Integer id; private String name; private int gender; private Timestamp birthday; private String email; private String phone;&#125; UserMapper.xml 里面有些什么 [6.2]1.先贴代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.hello.mybatis.repository.mybatis.mapper.UserMapper"&gt; &lt;resultMap id="userResultMap" type="com.hello.mybatis.repository.pojo.User"&gt; &lt;id property="id" column="id" javaType="java.lang.Integer" jdbcType="INTEGER"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="gender" column="gender"/&gt; &lt;result property="birthday" column="birthday"/&gt; &lt;result property="email" column="email"/&gt; &lt;result property="phone" column="phone"/&gt; &lt;/resultMap&gt; &lt;insert id="createUser" parameterType="com.hello.mybatis.repository.pojo.User" useGeneratedKeys="true" keyProperty="id"&gt; INSERT INTO user ( name, gender, birthday, email, phone ) VALUES ( #&#123;name&#125;, #&#123;gender&#125;, #&#123;birthday&#125;, #&#123;email&#125;, #&#123;phone&#125; ); &lt;/insert&gt; &lt;select id="selectUserById" parameterType="int" resultMap="userResultMap"&gt; SELECT * FROM user WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id="listUserByIdList" resultMap="userResultMap"&gt; SELECT * FROM user WHERE id IN &lt;foreach item="item" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/select&gt;&lt;/mapper&gt; 2.namespace 指向定义的 mapper 。这个是重点，也是很容易踩进去的坑。要特别注意。另外一点就是，mapper接口里是可以直接定义 sql 的，具体请 Google。 3.resultMap 定义的是数据库表和模型对象之间的映射关系。mybatis会根据 resultMap 里的定义进行字段和对象属性之间的映射和转换。这里的 type 指向自定义的模型对象。 4.insert标签里的 useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; 会返回生成的自增主键值。 #{} 操作符用来获取对象相应属性的值。 5.parameterType 是传入数据的类型。 6.foreach 标签会遍历传入的 list。如果传入的 parameterType 为 map ，这里的 collection 可为自定义的 list 名称。 UserMapper 接口 [6.3]这个接口起着承上启下的作用。里面可以直接定义 sql 语句。如果不在此接口内的方法上方定义 sql，那么里面的方法名，参数列表，返回值必须与 *Mapper.xml 里面各种 sql标签一致。sql 标签的 id 值即为方法名。12345public interface UserMapper &#123; int createUser(final User user); User selectUserById(final int id); List&lt;User&gt; listUserByIdList(final Collection&lt;Integer&gt; idList);&#125; MybatisRepository 的实现类 [6.4]同样，考虑到篇幅的问题，这里只列举了一个方法作为示范，具体请查看源代码。这个类里请注意这几点： 注入 SqlSession 通过 SqlSession 获取 UserMapper 用 Mapper 来访问数据库 1234567891011121314151617181920212223242526@Repositorypublic class UserMybatisRepositoryImpl implements UserMabatisRepository &#123; @Inject private SqlSession sqlSession; private final static Logger log = LoggerFactory.getLogger(UserMybatisRepositoryImpl.class); private UserMapper getMapper() &#123; return this.sqlSession.getMapper(UserMapper.class); &#125; @Override public int createUser(User user) throws DatabaseException &#123; int result = getMapper().createUser(user); if (result &lt;= 0) &#123; log.error("[createUser] - Fail to create user[&#123;&#125;]", user.toString()); throw new DatabaseException("[createUser] - Fail to create user: " + user.toString()); &#125; return 0; &#125;&#125; Service 方法 [6.5]因为这个项目逻辑相对简单，所以 Service 中并未出现很多业务处理的操作。只是简单的判断了下 Request对象，对 Response进行了封装。更多的只是从注入的 MybatisRepository 直接访问数据库。123456789101112131415161718192021222324@Servicepublic class UserServiceImpl implements UserService &#123; @Inject private UserMabatisRepository userMabatisRepository; @Override public BaseResp createUser(CreateUserReq req) &#123; if (req == null) &#123; return new BaseResp(false, "Null Request!"); &#125; User user = new User(req.getName(), req.getGender(), req.getBirthday(), req.getEmail(), req.getPhone()); try &#123; userMabatisRepository.createUser(user); &#125; catch (DatabaseException e) &#123; return new BaseResp(false, e.toString()); &#125; return new BaseResp(true, "OK"); &#125;&#125; 简单粗暴的 Controller [6.6]1234567891011121314@Controller@RequestMapping("/user")public class UserController &#123; @Inject private UserService userService; @ResponseBody @RequestMapping(value = "/create-user", method = RequestMethod.POST, produces = "application/json;charset=UTF-8") public BaseResp createUser(@RequestBody CreateUserReq req) &#123; return userService.createUser(req); &#125;&#125; 写在最后再一次:源码地址 -&gt; https://github.com/GavinLee1/HelloMybatis.git References[1] GitBook - SpringBoot参考指南 Spring-Boot-Reference-Guide[2] What’s Mybatis[3] Mybatis - Spring]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[十步之内轻松搞定 Hexo + GitHub搭建个人博客]]></title>
      <url>%2F2017%2F02%2F25%2F%E5%8D%81%E6%AD%A5%E4%B9%8B%E5%86%85%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9A-Hexo-GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[最近刚把个人博客站点搭起来，应几个朋友之邀，同时也是趁着自己还没忘，赶快把搭建过程记录分享一下。因为GitHub我一直有在用，所以个人感觉没有很复杂。如果你对细节没有太多要求的话，跟着这个教程，差不多个2个小时左右可以轻松搞定。如果，你想去仔细研究配置和主题的东西，半天时间下来也差不多可以上线。所以，总的来看就是这么个工作量。具体的，我们接下来慢慢聊。 包含的所有技术关键词 以及 简单介绍Git: 其实说白了就是帮你管理代码，进行版本控制。让你life easier的东西。官网是这么介绍自己的: Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. 如果你没用过Git, 官方有一个在线的bash 请戳 -&gt; https://try.github.io/levels/1/challenges/1拢共大概十个命令，日常工作也完全是够用了。更高级的用法请自行Google… GitHub: 我也不瞎编了, 人家维基百科[3]是这么说的： GitHub是一个通过Git进行版本控制的软件源代码托管服务。GitHub同时提供付费账户和免费账户。这两种账户都可以创建公开的代码仓库，但是付费账户还可以创建私有的代码仓库。根据在2009年的Git用户调查，GitHub是最流行的Git访问站点。除了允许个人和组织创建和访问保管中的代码以外，它也提供了一些方便社会化共同软件开发的功能，即一般人口中的社区功能，包括允许用户追踪其他用户、组织、软件库的动态，对软件代码的改动和bug提出评论等。GitHub也提供了图表功能，用于概观显示开发者们怎样在代码库上工作以及软件的开发活跃程度。 Hexo: 是一个快速，简洁且高效的博客框架 中文官方网站 Markdown: 所有博客原始文件都是 .md 文件。都是用它来写的。好吧，如果你知道 txt 的话，其实他们是一类玩意儿。 Markdown 是一种轻量级标记语言，创始人为約翰·格魯伯（John Gruber）。 它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。 画个分界线 - 教程正式开始 如果你用MacOS, 请先安装一下 brew [1]ruby -e "$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)" 安装 Git [2]brew install git Windows下安装配置Git请参考: Win7上Git安装及简单配置过程 注册GitHub 获取并上传本机SSH 新建一个代码库 [3]注册GitHub [3.1] 登录官网，一步一步往下点就行了 获取并上传本机SSH [3.2] 关于这一步, GitHub上面有很清晰的指导 -&gt; 链接地址为了本文的完整性，我截几个图放这里: 首先查看自己电脑里是否已经有了SSH key, 如果有了直接上传就行[3.2.1]ls -al ~/.ssh 如果还没有, 你需要执行以下几步 [3.2.2] 上一步成功之后 [3.2.3]去你的本地找到以下文件，拷贝里面的内容 注意不要前后空格然后回到, GitHub, 到以下页面进行添加 新建一个代码库 - 这个略关键 [3.3] 首先，GitHub有个功能叫 GitHub Pages。这个也是本教程的关键。你可以使用GitHub Pages直接从代码库生成个人站点，运行之后，直接通过GitHub提供的域名（用户名+github+io)进行访问。但是，为了使用这个功能，我们必须符合他们的规范: 新建Repository时, name 对应处填写资源名，需要使用自己的用户名，每个用户名下面只能建立一个，资源命名 必须符合这样的规则username/username.github.io 首页选择新建Repository [3.3.1] 项目名称设置为 yourname.github.io 并clone到本地 [3.3.2] 项目创建成功之后，去项目页面，点击settings [3.3.3]页面往下拉，找到 GitHub Pages 分支选择master 并保存大概过10分钟左右，你的页面就可以直接通过yourname.github.io进行访问了 重点来了 - 安装 Hexo [4]开始之前, 请确保你的本机成功正确的安装了Node。如果没有, 如果你用Mac, 同样一键傻瓜式安装: brew install node Windows 同样请参考 -&gt; Node.js 安装配置 其实吧, Hexo 安装起来超级简单, 就一行命令就行: $ npm install hexo-cli -g 继续划重点 - 初始化 Hexo [5]先建个文件夹 mkdir HelloBlog 进入文件夹, 执行命令: hexo init npm install 然后等待 下载安装一大堆东西 … 大概应该是这个样子的 … 这两步完成之后, 当前目录下, 继续执行命令: hexo generate 或者是 hexo g 然后, 执行: hexo server 或者是 hexo s 你就会发现, 本地的Blog已经跑起来了… 重点中的重点 - 修改配置文件并部署到GitHub [6]首先来看一下, 初始化项目的目录结构长什么样子…我们需要修改的就是根目录下的这个 _config.yml 顺嘴提一句, 博客的原始文件会存在source/_posts/ 下面 用 Sublime 或者 Atom 打开文件进行修改关于配置文件的具体信息, 可以参考 -&gt; https://hexo.io/zh-cn/docs/configuration.html 首先是改一下Blog的基本信息: 最重要的是添加部署的信息, deploy这里只用替换repo就行了, 指向你在GitHub里新建的那个库 修改完, 保存之后, 根目录下执行: hexo deploy 或者 hexo d 如果一切顺利的话, 就可以成功部署到GitHub上了等几分钟就可以通过 -&gt; gavinlee1.github.io 进行访问了 你感兴趣的 - 关于主题的事情 [7]Hexo有很多开源的主题和插件可以添加配置。以本博客为例, 我用的主题叫 Yelee 可以在github上找到源码和对应的wiki介绍。添加个人主题, 主要有这么几步: 在 theme 目录下 git clone 你想要的主题 [7.1] 修改全局配置文件 (/_config.yml) - 替换主题 [7.2] 配置和定制主题的显示内容 [7.3]你可以在 https://hexo.io/themes/ 这里找到你想要的主题。但是不同主题有自己的配置信息结构和修改方法, 具体需要参考你所选主题在GitHub上的wiki。当然, 万变不离其宗的是修改主题目录下的(_config.yml) 以我用的主题为例 Yelee 主题使用说明 [简中] 官方提供完整的配置使用说明书。你可以参考该说明, 修改配置文件, 字体, 高亮格式 以及 包括分享 评论 在内的各种插件。 怎么写博客？ [8]执行命令: hexo new post "This is the tile for new post." 这个命令会在 /source/_post/ 下生成 title.md 文件。这个.md文件就是你博客的原始文件。编辑完之后，hexo会解析这个文件生成对应的静态网页。然后执行命令进行部署: hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 还等什么？ 赶快搭建你自己的Blog咯References[1] Git https://git-scm.com/[2] Hexo https://hexo.io/zh-cn/[3] 维基百科 - GitHub https://zh.wikipedia.org/wiki/GitHub[4] Win7上Git安装及简单配置过程[5] Node.js 安装配置[6] Yelee 主题使用说明 [简中]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World来谈谈为什么写博客]]></title>
      <url>%2F2017%2F02%2F23%2FHello-World%E6%9D%A5%E8%B0%88%E8%B0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[建立个人博客这个念头已经兜兜转转很多年了。但是，一直由于各种俗世缠身,年轻的时候受限于技术与资源, 上学的时候各种项目各种作业各种活动, 快毕业要找工作, 刚工作又忙试用期, 然后就是工作工作工作...，所以一拖就是好几年…最近咬了咬牙，挤了点时间，终于是把台子搭起来了。接下来就看怎么表演了… Anyway… 回到正题… 只是因为翻了翻多年不用的QQ空间 …其实一直都超级忙…自从新工作入职，一直都是开挂的节奏。所以并不是闲来无事写博客。这个观点，我想开篇就否定掉。 那天晚上失眠，不太好睡觉，索性点开了QQ空间乱翻翻。我的QQ空间其实已经关闭快6年了，很久很久都没更新了。所以，上面留下的记录全都是很多年前的。有些说说，日志，照片…都是跟那个年代的自己有关的东西。突然勾起了好多回忆：很多已经好久都不联系的同学，朋友…年少轻狂的自己说过的很多矫情的话…还有十几岁跟小D最初的互动…等等好多的片段。这种感觉很微妙，怃然的就感觉很美好。 然后我就想，当下的自己因为十几年前留下的印记，唤回了很多回忆，甚至是一些已经被忽略很多年的记忆。那，此时此刻，我又为什么不为多年之后的自己再留下一些东西呢？索性搭个自己的Blog吧。所以，咬咬牙就到了现在。 BLOG真的是上个世纪的事了吗？ 提到了QQ空间，感觉都是互联网石器时期的东西了。不过，这个问题我不想答，我只是放在这里，大家自己思考，毕竟每个人都有自己的判断。不过，我想提几个关键词：GitHub PagesHexoJekyll简书所以，你觉得呢？ 互联网精神：分享 众所周知，互联网缘起于分享。分享，也是被广泛宣传和接受的互联网精神。作为这个行业的从业人员，互联网是我们赖以为生的生态系统。所以，分享这个基本点，我们一定要把握好，坚持住。 这次，认真开始写博客。主题其实很明确，就是想把平时看到的，遇到的，或者是听到的，一些跟技术有关的东西。都总结总结，过一遍脑子，然后用自己的话再写出来。社会越来越浮躁，不忘初心，守住本性，静下心来好好的写东西。想想，也是一件轶事。 你若盛开 清风自来 保持朝圣心态 - Stay Hungry - 学海无涯 这是一个站在巨人肩膀上摘苹果的时代。但凡牛逼的公司，都会维护自己的知识共享平台。我一直都觉得，组织梳理已经过了一遍脑子的东西，是有效学习的捷径。话不多说，分享几个牛逼的大博客：1 腾讯 ISUX 设计师腾讯社交用户体验设计，简称ISUX (Internet Social User Experience)，成立于2011年1月11日，是腾讯集团核心、全球最具规模的UX设计团队。ISUX主要负责腾讯社交通讯与娱乐类产品服务的用户体验设计与研究，包括主要服务平台如QQ、QQ空间、QQ会员、QQ钱包、QQ运动、腾讯云、腾讯企点、QQ物联、腾讯课堂、兴趣部落、花样直播、全民K歌、全民影帝、企鹅FM、闪咖、天天P图、微云和来电等。 2 LinkedIn Engineering作为全球最大的职业社交网站，LinkedIn 会员人数在世界范围内已超过 3 亿。这是LinkedIn旗下的科技博客，涵盖的内容非常丰富。从各个方面详细地介绍了LinkedIn技术人员如何使用高度结构化的数据来完成LinkedIn的搜索功能、社交图谱以及机器学习系统。此外，还有对于其工程研发团队所创造、管理和使用的开源产品细致化讲解。另外还包含精彩博文，有关于LinkedIn背后的技术背景、团队开发人员介绍等等您都可以在这里一网打尽，非常值得我们学习借鉴。 3 Twitter EngineeringTwitter是一家美国社交网络及微博客服务的网站，是全球互联网上访问量最大的十个网站之一。这是Twitter官方推出的技术博客，经由Twitter工程研发团队所维护管理，第一时间发布一手的有关Twitter的技术、工具以及活动信息。向业内外人士展示Twitter背后的工具、产品。还包括受到大家强烈关注的，Twitter发布的开源产品信息介绍。 4 谷歌开源谷歌，是一家美国的跨国科技企业，致力于互联网搜索、云计算、广告技术等领域，开发并提供大量基于互联网的产品与服务。这个科技博客发布了Google所有的开源产品项目的新闻消息，并会及时更新开源软件的开发信息。Google是支持开源运动的最大公司之一，如果您想第一时间了解新开源的产品，学习Google的实践经验，及时掌握Google的核心关键技术，向Google开发团队表达自己的建议，那这一定会是您最好的去处。 5 NGINXNginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。中国大陆使用NGINX网站用户有：百度、新浪、网易、腾讯等。在NGINX的技术博客，您可以看到NGINX的新闻、技术信息和科技交流活动安排。对于NGINX的技术发布、核心技术信息都在这里一一呈现。关注这个微博，您可以第一时间看到有关于NGINX的技术咨询。如果您对这个高性能的HTTP和反向代理服务器非常感兴趣，请您一定要关注它！ 6 O’Reilly洞悉、分析和研究新兴技术是其宗旨。该博客有请O’Reilly公司的专栏编辑，撰写各个领域的技术类文章。迎合技术开发者的需求，追踪最前沿技术，每篇文章定位读者精确，您可以选择自己最感兴趣的方面进行阅读。 7 DropboxDropbox是最实用且免费的云存储软件。每天全世界有亿万用户正在使用Dropbox,它提供在电脑、手机、平板,甚服务器上同步、备份或共享文件资料。Dropbox的科技博客，会时常发布一些Dropbox的新产品和新功能详细介绍。每篇文章讲解地非常详细，方方面面的细节也非常到位。 8 UberUber(优步)是一款全球即时用车软件,已覆盖全球55个国家,300多个城市。Uber旨在为大家带来更安全舒适的出行方式,让城市更方便快捷。Uber的技术博客，及时更新介绍Uber背后的精良算法和产品设计，提供对其核心算法和服务技术的剖析，分享了Uber技术发布和其开源项目。 9 AWSAWS即Amazon Web Services，是亚马逊（Amazon）公司的云计算IaaS和PaaS平台服务。AWS的技术博客涵盖的内容非常丰富，有AWS服务支持，在国内外知名公司的用例分享，成熟的服务与应用平台架构分析，旗下技术产品更新发布，AWS优秀开发者介绍等等内容，只要您能想得到的方面都可以在上面找到相应解答。博文都是有请AWS自身技术开发人员撰写，以其独到的视角、犀利的文字，向您一一展示AWS技术的魅力所在。 10 GitHub Engineering作为开源代码库以及版本控制系统，Github拥有140多万开发者用户。这是由GitHub的一线技术工程师，根据自身开发GitHub环节中遇到的问题、使用的最新技术所撰写的博客。由于作者都是非常有经验的工程师，您可以深入了解GitHub后台结构，对您的相关开发一定有很大帮助。 即是分享也是记录 想想几个场景： 需要用Jmeter重新测性能，但是突然忘了流程是什么。 好像之前看到 Spring Boot 里有个注解很有用，但是到底是什么？ Mybatis的xml配置文件里，插入成功返回主键值是怎么配置来着？我记得只有两句话…是啥？… 找工作面试之前，想想，我前两年到底TMD干了些什么，有些什么可以拿来讲的？ … 等等…等等…所以，维护好自己的博客主站，坚持下来，不但可以分享一些自己的心得体会。写博客也是一种记录的有效途径。不仅可以帮自己进一步加深印象，理清思路。还可以在某些情境中，起到关键作用。言而总之，Why Not？ GitHub不倒，20年后再见You Can You Up不作总结 这只是开始]]></content>
    </entry>

    
  
  
</search>
